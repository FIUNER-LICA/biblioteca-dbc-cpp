{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"C++ Design by Contract Library Documentation Diaz Zamboni Javier E. - Insfr\u00e1n Jord\u00e1n F. - Garcia Justo This library enables you to specify and enforce contracts (preconditions, postconditions, and invariants) in your C++ code, aiming to promote robustness and reliability. Table of Contents Installation Basic Usage Features Preconditions Postcondition Invariants API-Reference License Installation To integrate the DbC library into your C++ project, follow these installation steps: Clone the repository from GitHub git clone https://github.com/FIUNER-LICA/biblioteca-dbc-cpp.git Include the contract.h header file in your project. #include \"contract.h\" Ensure your compiler supports C++11 or later. Basic Usage Here's a basic example to get you started with the DbC library using pre and post conditions as functions: #include <iostream> #include \"contract.h\" using namespace contract; void example_function(int x) { precondition(x > 0, \"x must be greater than 0\"); // Function logic here postcondition(x < 100, \"x should be less than 100\"); } int main() { try { example_function(50); } catch (const violation_error& e) { std::cerr << \"Contract violation: \" << e.what() << std::endl; } return 0; } Features Preconditions Preconditions specify conditions that must be true at the entry of a function or method. Here's how to use preconditions effectively: Function Syntax : As function: precondition(expression, message) As class: precond(expression, message) As macro: REQUIRE(expression, message) Example: void example_function(int x) { precond(x > 0, \"x must be greater than 0\"); // As class precondition(x > 0, \"x must be greater than 0\"); // As function REQUIRE(x > 0, \"x must be greater than 0\"); // As macro // Function logic. } Postconditions Postconditions specify conditions that must be true at the exit of a function or method. They validate the expected outcomes and state changes after the execution of a routine. Here's how to use postconditions effectively: Function Syntax : As function: postcondition(expression, message) As class: postcond(expression, message) As macro: ENSURE(expression, message) Example: void example_function(int x) { //Function logic. postcondition(x < 100, \"x should be less than 100\"); // As function postcond(x < 100, \"x should be less than 100\"); // As class ENSURE(x < 100, \"x should be less than 100\"); // As macro } Invariants Invariants specify conditions that must be true for a class or object, ensuring its integrity throughout its lifecycle. Here's how to use invariants effectively:","title":"Home"},{"location":"#c-design-by-contract-library-documentation","text":"Diaz Zamboni Javier E. - Insfr\u00e1n Jord\u00e1n F. - Garcia Justo This library enables you to specify and enforce contracts (preconditions, postconditions, and invariants) in your C++ code, aiming to promote robustness and reliability.","title":"C++ Design by Contract Library Documentation"},{"location":"#table-of-contents","text":"Installation Basic Usage Features Preconditions Postcondition Invariants API-Reference License","title":"Table of Contents"},{"location":"#installation","text":"To integrate the DbC library into your C++ project, follow these installation steps: Clone the repository from GitHub git clone https://github.com/FIUNER-LICA/biblioteca-dbc-cpp.git Include the contract.h header file in your project. #include \"contract.h\" Ensure your compiler supports C++11 or later.","title":"Installation"},{"location":"#basic-usage","text":"Here's a basic example to get you started with the DbC library using pre and post conditions as functions: #include <iostream> #include \"contract.h\" using namespace contract; void example_function(int x) { precondition(x > 0, \"x must be greater than 0\"); // Function logic here postcondition(x < 100, \"x should be less than 100\"); } int main() { try { example_function(50); } catch (const violation_error& e) { std::cerr << \"Contract violation: \" << e.what() << std::endl; } return 0; }","title":"Basic Usage"},{"location":"#features","text":"","title":"Features"},{"location":"#preconditions","text":"Preconditions specify conditions that must be true at the entry of a function or method. Here's how to use preconditions effectively: Function Syntax : As function: precondition(expression, message) As class: precond(expression, message) As macro: REQUIRE(expression, message) Example: void example_function(int x) { precond(x > 0, \"x must be greater than 0\"); // As class precondition(x > 0, \"x must be greater than 0\"); // As function REQUIRE(x > 0, \"x must be greater than 0\"); // As macro // Function logic. }","title":"Preconditions"},{"location":"#postconditions","text":"Postconditions specify conditions that must be true at the exit of a function or method. They validate the expected outcomes and state changes after the execution of a routine. Here's how to use postconditions effectively: Function Syntax : As function: postcondition(expression, message) As class: postcond(expression, message) As macro: ENSURE(expression, message) Example: void example_function(int x) { //Function logic. postcondition(x < 100, \"x should be less than 100\"); // As function postcond(x < 100, \"x should be less than 100\"); // As class ENSURE(x < 100, \"x should be less than 100\"); // As macro }","title":"Postconditions"},{"location":"#invariants","text":"Invariants specify conditions that must be true for a class or object, ensuring its integrity throughout its lifecycle. Here's how to use invariants effectively:","title":"Invariants"},{"location":"apireference/","text":"API Reference Classes contract::violation_error Represents an exception thrown when a contract violation occurs. Constructor violation_error(std::string msg); Constructs a violation_error object with the specified error message. Member Functions virtual const char* what() const noexcept; Returns a string describing the exception. contract::Invariant Manages class invariants and performs invariant checks. Constructor Invariant(); Member Functions void operator()(bool logix_exp, const std::string msg); Overloaded function call operator to evaluate and enforce class invariants. void add_invariant(std::function<bool()> p_lambda); Adds a new invariant to the collection. void check_invariant(); Check all invariants and throws violation_error if any invariant fails. contract::Contract Handles logical expressions and throws exceptions for contract violations. Member Functions void operator()(bool logic_exp, const std::string msg = \"\"); Evaluates a logical expression and throws an exception with a specified message if the expression is false. Functions contract::precondition Evaluates preconditions for a function or method. void precondition(const bool logic_exp, const std::string msg = \"\"); Throws violation_error if logic_exp is false, with an optional error message. contract::postcondition Evaluates postconditions for a function or method. void postcondition(const bool logic_exp, const std::string msg = \"\"); Throws violation_error if logic_exp is false, with an optionar error message. Macros Coming soon... REQUIRE ENSURE ASSURE INVARIANT","title":"API-Reference"},{"location":"apireference/#api-reference","text":"","title":"API Reference"},{"location":"apireference/#classes","text":"","title":"Classes"},{"location":"apireference/#contractviolation_error","text":"Represents an exception thrown when a contract violation occurs.","title":"contract::violation_error"},{"location":"apireference/#constructor","text":"violation_error(std::string msg); Constructs a violation_error object with the specified error message.","title":"Constructor"},{"location":"apireference/#member-functions","text":"virtual const char* what() const noexcept; Returns a string describing the exception.","title":"Member Functions"},{"location":"apireference/#contractinvariant","text":"Manages class invariants and performs invariant checks.","title":"contract::Invariant"},{"location":"apireference/#constructor_1","text":"Invariant();","title":"Constructor"},{"location":"apireference/#member-functions_1","text":"void operator()(bool logix_exp, const std::string msg); Overloaded function call operator to evaluate and enforce class invariants. void add_invariant(std::function<bool()> p_lambda); Adds a new invariant to the collection. void check_invariant(); Check all invariants and throws violation_error if any invariant fails.","title":"Member Functions"},{"location":"apireference/#contractcontract","text":"Handles logical expressions and throws exceptions for contract violations.","title":"contract::Contract"},{"location":"apireference/#member-functions_2","text":"void operator()(bool logic_exp, const std::string msg = \"\"); Evaluates a logical expression and throws an exception with a specified message if the expression is false.","title":"Member Functions"},{"location":"apireference/#functions","text":"","title":"Functions"},{"location":"apireference/#contractprecondition","text":"Evaluates preconditions for a function or method. void precondition(const bool logic_exp, const std::string msg = \"\"); Throws violation_error if logic_exp is false, with an optional error message.","title":"contract::precondition"},{"location":"apireference/#contractpostcondition","text":"Evaluates postconditions for a function or method. void postcondition(const bool logic_exp, const std::string msg = \"\"); Throws violation_error if logic_exp is false, with an optionar error message.","title":"contract::postcondition"},{"location":"apireference/#macros","text":"Coming soon...","title":"Macros"},{"location":"apireference/#require","text":"","title":"REQUIRE"},{"location":"apireference/#ensure","text":"","title":"ENSURE"},{"location":"apireference/#assure","text":"","title":"ASSURE"},{"location":"apireference/#invariant","text":"","title":"INVARIANT"},{"location":"license/","text":"MIT License Copyright (c) 2024 Laboratorio de Inform\u00e1tica y Computaci\u00f3n Aplicada Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}